class InputCell {
    constructor(num) {
        this.value = num;
        this.observers = [];
    }
    //it adds an observer to this inputCell
    subscribe(observer) {
        this.observers.push(observer);
    }
    //when the setValue is call it updates this.value, and call updateMe methods for every obserever
    setValue(num) {
        if (num != this.value) {
            this.value = num;
            //it binds an unique symbol at this call; this is necessary for add only one element in CallbackCell.values
            const changeID = Symbol()
            this.observers.forEach(observer => observer.updateMe(changeID));
        }
    }
}

class ComputeCell {
    updateMe(changeID) {
        const prevValue = this.value;
        this.value = this.func(this.myInputCells);
        if (prevValue != this.value)
            this.observers.forEach(observer => observer.updateMe(changeID));
    }
    subscribe(observer) {
        this.observers.push(observer);
    }
    constructor(cells, func) {
        this.value = null;
        this.func = func;
        this.myInputCells = cells;
        //I declare myself an observer of every cell, both input and compute
        this.myInputCells.forEach(cell => cell.subscribe(this));
        this.observers = [];
        this.updateMe();
    }
    addCallback(callback) {
        callback.myInputCell = this;
        callback.prevValue,  callback.valueBeforeCallbackCell = callback.func(this);
        this.subscribe(callback);
    }
    removeCallback(callback) {
        this.observers = this.observers.filter(subscriber => subscriber !== callback);
    }
}
class CallbackCell {
    constructor(func) {
        this.valueBeforeCallbackCell=null;
        this.prevValue = null;
        this.values = [];
        this.myInputCell = null;
        this.func = func;
        this.changeID = null;
    }
    updateMe(changeID) {
        const newValue = this.func(this.myInputCell);
        //if the value doesen't change i don't do anything
        if (this.prevValue != newValue) {
            //if the change is generated by the same setValue call, then I override the value
            if (changeID == this.changeID) {
                this.values[this.values.length - 1] = newValue;
                this.prevValue = newValue;
                //I have to check if with this override I obtain the valueBeforeCallbackCell
                //in this case nothing change and values have to be empty
                if (this.values.length ==  1 && this.values[0] ==  this.valueBeforeCallbackCell)
                    this.values=[];
            }
            //I add the new value
            else {
                this.values.push(newValue);
                this.prevValue = newValue;
                this.changeID = changeID;
            }
        }
    }
}


export { InputCell, ComputeCell, CallbackCell };